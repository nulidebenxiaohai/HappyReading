# Java程序概述

## Java关键术语

| 1.简单性       | 7.可移植性 |
| -------------- | ---------- |
| 2.面向对象     | 8.解释性   |
| 3.分布式       | 9.高性能   |
| 4.健壮性       | 10.多线程  |
| 5.安全性       | 11.动态性  |
| 6.体系结构中立 |            |

# 基本概念

## 数据类型

  Java是一种强类型语言。这就是意味着必须为每一种类型。在Java中，一共8种基本类型(primitive type)，其中有4种整型，2种浮点类型，1种字符类型char(用于表示Unicode编码的代码单元)和一种用于表示真值的boolean类型

### 整型

![image-20211109002735538](Core Java Volume I-Fundamentals.assets/image-20211109002735538.png)

在Java当中，整型的范围与运行Java代码的机器无关。这就解决了软件从一个平台移植到另一个平台的，或者在同一个平台中的不同操作系统之间进行移植给程序员带来的诸多问题。



长整型数值有一个后缀L或l(如4000000000l)。十六进制属猪有一个前缀0x或0X(0xCAFE)。八进制有一个前缀0.

### 浮点类型

浮点类型用于表示有小数部分的数值。在Java中有两种浮点类型。

![image-20211109003558630](Core Java Volume I-Fundamentals.assets/image-20211109003558630.png)

float类型的数值有一个后缀F或f(例如：3.14f)。没有后缀F的浮点数值(如3.14)总是默认为double类型。

### Char类型

char类型原本用于表示单个字符。不过，现在情况已经有所变化。如今，有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。

char类型的字面量值要用单引号括起来。例如：‘A’是编码值为65的字符常量。它与“A”不同。char类型的值可以表示为十六进制值，其范围从\u000到\uFFF。

### boolean类型

boolean(布尔)类型有两个值：false和true，用来判定逻辑条件。整数值和布尔值之间不能相互转换。

# 变量和常量

## 声明变量

在Java中，每个变量都有一个类型(tpye)。在声明变量是，先制定变量的类型，然后是变量名。例如：

​    double salary;

​    int vacationDays;

变量名必须是一个以字母开头并且由字母或数字构成的序列。

注意：大小写敏感！！！(同时不能使用Java保留字作为变量名)

## 变量初始化

声明一个变量之后，必须用赋值语句对变量进行显式初始化，千万不要使用未初始化的变量的值。

在Java中，变量的声明尽可能地靠近变量第一次使用的地方，这是一种良好的程序编写风格。

## 常量

在Java中，利用关键字final指示常量。

关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能再更改了。习惯上，常量名使用全大写。

在Java中，经常希望某个常量可以在一个类的多个方法中使用，通常将这些常量称为类常量(class constant)。可以使用关键字static final设置一个类常量。

需要注意，类常量的定义位于main方法的外部。因此，在同一个类的其他方法中也可以这个常量。而且，如果一个常量被声明为public，那么其他类的方法也可以使用这个常量。

## 枚举类型

有时候，变量的取值挚爱一个有限的集合内。例如，销售的服装或者披萨只有小，中，大和超大这四种尺寸。

针对这种情况，可以自定义枚举类型。枚举类型包括有限个命名的值。例如：

enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE};

现在可以声明这种类型的变量：

Size s = Size.MEDIUM；

Size类型的变量只能储存这个类型声明中给定的某个枚举值，或者特殊值null，null表示这个变量没有设置任何值。

## 运算符

### 算术运算符

Java的算数运算符有+ - * /。当参与 / 运算的两个操作数都是整数时，表示整数除法，否则表示浮点除法。整数的求余操作(又是被称为取模)用%表示。

注意：整数被0除以会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果。

### 数学函数与常量

在Math类中，包含了各种个样的数学函数。在编写不同类别的程序时，可能需要的函数也不同。

想要计算一个数值的平方根，可以使用sqrt方法：

double x = 4;

Double y = Math.sqrt(x);

System.out.println(y);//prints 2.0

> println方法和sqrt方法存在微小的差异。println方法处理System.out对象。但是，Math类中的sqrt方法并不处理任何对象，这样的方法被称为静态方法。

在Java中，没有幂函数，因此需要借助与Math类的pow方法。例如：

double y = Math.pow(x,a);

将y的值设置为x的a次幂。pow方法有两个double类型的参数，其返回结果也为double类型。

Math类提供了一些常用的三角函数；

Math.sin

Math.cos

Math.tan

Math.atan

Math.atan2

还有指数函数以及它的反函数——自然对数以及以10为底的对数：

Math.exp

Math.log

Math.log10

最后，Java还提供了连个用于表示PI和E常量的最接近的近似值：

Math.PI

Math.E

### 数值类型之间的转换

<img src="Core Java Volume I-Fundamentals.assets/image-20211109163313232.png" alt="image-20211109163313232" style="zoom:50%;" />



实现箭头表示无信息丢失的转换；另外有3个虚线箭头，表示可能有精度损失的转换。

### 强制类型的转换

在必要的时候，int类型的值将会自动转换为double类型。但另一方面，有时候也学需要将double转换成int。在Java中，允许这种数值之间的类型转换，不过这个操作可能会丢失一些信息。这种可能损失信息的转化要通过强制类型转换(cast)来完成。强制类型转换的语法格式为：

double  x = 9.997;

int nx = (int) x;

这样，变量nx的值为9，因为强制类型转换通过截断小数部分将浮点值转换为整数。

### 结合赋值和运算符

可以在赋值中使用二元运算符，这是一种很方便的简写形式。例如：

x += 4;

等价于：

x = x + 4;

(一般来说，要把运算符放在=号左边，如*=或%=)

> 如果运算符得到一个值，其符号与左侧操作数的类型不同，就会发生强制转换。例如，如果x是一个int，则下面语句：
>
> x += 3.5;
>
> 是合法的，将把x设置为(int)(x+3.5)

### 自增与自减运算符

Java中提供了自增，自减运算符(n++,n--)。也有前缀形式：++n/--n。后缀和前缀形式都会使变量值加1或者减1.但用在表达式中时，二者就有区别了。前缀形式会先完成+1；而后缀形式会使用变量原来的值。

int m = 7;

int n = 7;

int a = 2 * ++m //now a is 16, m is 8

int b = 2 * ++n  //now b is 14, n is 8

建议不要在表达式中使用++，因为这样的代码很容易让人困惑，而且会带来烦人的bug

### 关系和boolean运算符

&& 与

||    或

！   非

### 位运算符

处理整数类型时，可以直接对组成整数的各个位完成操作。这意味着可以使用掩码技术得到整数中的各个位。位运算符包括：

&： and

| ： or

^:  xor

~:  not

这些运算符按位模式处理。

> 应用在布尔值上时，&和|运算符也会得到一个布尔值。这些运算符和&&和||运算符很类似，不过&和|运算符不采用“短路”方式来求值，也就是说，得到计算结果之前两个操作数都需要计算

另外，还有>>和<<运算符可以将位模式左移和右移。需要建立位模式来完成位掩码时，这两个运算符为很方便。

最后，>>>运算符会用0填充高位，这与>>不同，它会用符号填充高位。不存在<<<运算符。

### 运算符优先级

| 运算符                                 | 结合性   |
| -------------------------------------- | -------- |
| [] . ()(方法调用)                      | 从左向右 |
| ！ ~ ++ -- + （） （强制类型转换） new | 从右向左 |
| * 、 %                                 | 从左向右 |
| + -                                    | 从左向右 |
| <<  >>  >>>                            | 从左向右 |
| < <= >= instanceof                     | 从左向右 |
| == !=                                  | 从左向右 |
| &                                      | 从左向右 |
| ^                                      | 从左向右 |
| \|                                     | 从左向右 |
| &&                                     | 从左向右 |
| \|\|                                   | 从左向右 |
| ?:                                     | 从右向左 |
| = += -= *= %= &= \|= ^= >>= <<= >>>=   | 从右向左 |

## 字符串

从概念上讲，Java字符串就是Unicode字符串序列。Java额米有内置的字符串类型，而是在标准Java类库中提供了一个与定义类，很自然就叫做String。每个用双引号括起来的字符串都是String类的一个实例。

### 字串

String类的substring方法可以从一个较大的字符串提取出一个子串。例如：

String s = greeting.substring(0,3); //截取字符串greeting 0~2 的字符串

substring方法的第二个参数是不想**复制**的第一个位置。这里要复制位置为0，1和2的字符。在substring中从0开始计数，直到3为止，但不包含3.

substring的工作方式有一个优点：容易计算字串的长度。字符串s.substring(a,b)的长度为b-a。

### 拼接

与绝大多数程序设计语言一样，Java语言允许使用+号连接(拼接)两个字符串。

当将一个字符串与一个非字符串的值进行拼接时，后者会转换为字符串。

### 不可变字符串

String类没有提供*修改*字符串中某个字符的方法。如果希望修改greeting中的内容，可以提取想要保留的字符串(用substring)，再与希望替换的字符拼接。

由于不能修改Java字符串中的单个字符，所以在Java文档中将String类对象称为是不可变的(immutable)，如同数字3永远是3一样，字符串“Hello”永远包含字符H,e,l,l和o的代码单元序列。字符串不可以变的设置有一个优点：编译器可以让字符串共享。

为了弄清具体的工作方式，可以想象将各个字符串存放在公共的存储池中。字符串变量指向存储池中相应的位置。如果复制一个字符串变量，原始字符串与复制的字符串共享公共相同的字符串。

总而言之。Java的设计者认为共享带来的共享率远远胜过于提取字串，拼接字符串所带来的低效率。我们发现，大多数情况下，我们都不会修改字符串，而只是需要对字符串进行比较。

### 检测字符串是否相等

可以使用equals方法检测两个字符串是否相等。对于表达式：

s.equals(t)

如果字符串s与字符串t相等，则返回true；否则，返回false。需要注意的是，s与t可以是字符串变量，也可以是字符串字面量。

想要检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase()方法。

**一定不要使用==运算符检测两个字符串是否相等！！！**这个运算符只能够确定两个字符串是否存放在同一个位置上。当然，如果字符串在同一个位置上，它们必然相等。但是，完全有可能将内容相同的多个字符串副本放置在不同的位置上。

如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。但是实际上只有字符串字面量是共享的，而+或substring等操作得到的字符串并不共享。因此，千万不要使用==运算符测试字符串的相等性，以免在程序中出现这种最糟糕的bug，看起来这种bug就像随机产生的间歇性错误。

### 空串与Null串

空串“”是长度为0的字符串。可以调用.length()来检查一个字符串是否为空(也可以用equals)。

空串是一个Java对象，有自己的串长度(0)和内容(空)。不过，String变量还可以存放一个特殊的值，名为null，表示目前没有任何对象与该变量关联。要检查一个字符串是否为null，要使用以下条件：

if (str = null)

### 码点与代码单元

Java字符串由char值序列组成。char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元



























